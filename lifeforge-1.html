<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LifeForge - Developmental Biology Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 100%);
            color: #e0f0ff;
            min-height: 100vh;
            overflow-x: hidden;
            touch-action: pan-y;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
        }
        
        @media (min-width: 768px) {
            .container {
                padding: 20px;
            }
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 20px;
            border-bottom: 2px solid #7fdbca;
        }
        
        @media (min-width: 768px) {
            header {
                padding: 30px 0;
                margin-bottom: 30px;
            }
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        @media (min-width: 768px) {
            h1 {
                font-size: 3rem;
            }
        }
        
        .tagline {
            font-size: 1rem;
            color: #a0c8ff;
            font-style: italic;
            margin-bottom: 8px;
        }
        
        @media (min-width: 768px) {
            .tagline {
                font-size: 1.2rem;
                margin-bottom: 10px;
            }
        }
        
        .subtitle {
            font-size: 0.9rem;
            color: #7fdbca;
        }
        
        @media (min-width: 768px) {
            .subtitle {
                font-size: 1rem;
            }
        }
        
        .main-layout {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        @media (min-width: 1024px) {
            .main-layout {
                display: grid;
                grid-template-columns: 300px 1fr;
                gap: 20px;
                margin-bottom: 30px;
            }
        }
        
        .control-panel {
            background: rgba(16, 32, 54, 0.7);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(79, 172, 254, 0.2);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            height: fit-content;
        }
        
        @media (min-width: 768px) {
            .control-panel {
                padding: 20px;
            }
        }
        
        .panel-title {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #4facfe;
            border-bottom: 1px solid rgba(79, 172, 254, 0.3);
            padding-bottom: 8px;
        }
        
        @media (min-width: 768px) {
            .panel-title {
                font-size: 1.3rem;
                margin-bottom: 20px;
                padding-bottom: 10px;
            }
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        @media (min-width: 768px) {
            .control-group {
                margin-bottom: 20px;
            }
        }
        
        .control-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #a0c8ff;
            font-size: 0.85rem;
        }
        
        @media (min-width: 768px) {
            .control-label {
                font-size: 0.9rem;
            }
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            border-radius: 5px;
            background: rgba(79, 172, 254, 0.2);
            outline: none;
            touch-action: none;
        }
        
        @media (min-width: 768px) {
            .slider {
                height: 6px;
            }
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #4facfe;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(79, 172, 254, 0.7);
        }
        
        @media (min-width: 768px) {
            .slider::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
            }
        }
        
        .slider-value {
            min-width: 45px;
            text-align: center;
            font-weight: bold;
            color: #4facfe;
            font-size: 0.9rem;
        }
        
        button {
            width: 100%;
            padding: 14px 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            color: #0a0e27;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
            font-size: 0.9rem;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        
        @media (min-width: 768px) {
            button {
                padding: 12px;
                font-size: 0.95rem;
            }
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }
        
        @media (hover: none) {
            button:hover {
                transform: none;
            }
        }
        
        button.secondary {
            background: rgba(79, 172, 254, 0.2);
            color: #4facfe;
        }
        
        button.danger {
            background: linear-gradient(90deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
        }
        
        .viz-container {
            background: rgba(16, 32, 54, 0.7);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(79, 172, 254, 0.2);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }
        
        @media (min-width: 768px) {
            .viz-container {
                padding: 20px;
            }
        }
        
        .canvas-wrapper {
            position: relative;
            background: #0a0e1a;
            border: 1px solid #334155;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
            touch-action: none;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 400px;
            touch-action: none;
        }
        
        @media (min-width: 768px) {
            canvas {
                height: 600px;
            }
        }
        
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        @media (min-width: 640px) {
            .stats-bar {
                grid-template-columns: repeat(4, 1fr);
                gap: 15px;
                margin-top: 20px;
            }
        }
        
        .stat-card {
            background: rgba(10, 22, 40, 0.8);
            padding: 12px;
            border-radius: 8px;
            border-left: 3px solid #4facfe;
            text-align: center;
        }
        
        @media (min-width: 768px) {
            .stat-card {
                padding: 15px;
            }
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4facfe;
            margin-bottom: 5px;
        }
        
        @media (min-width: 768px) {
            .stat-value {
                font-size: 1.8rem;
            }
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: #a0c8ff;
        }
        
        @media (min-width: 768px) {
            .stat-label {
                font-size: 0.85rem;
            }
        }
        
        .cell-legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 15px;
        }
        
        @media (min-width: 640px) {
            .cell-legend {
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                margin-top: 20px;
            }
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(10, 22, 40, 0.5);
            border-radius: 6px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            box-shadow: 0 0 8px currentColor;
            flex-shrink: 0;
        }
        
        @media (min-width: 768px) {
            .legend-color {
                width: 20px;
                height: 20px;
                box-shadow: 0 0 10px currentColor;
            }
        }
        
        .legend-label {
            font-size: 0.75rem;
            color: #cbd5e1;
        }
        
        @media (min-width: 768px) {
            .legend-label {
                font-size: 0.85rem;
            }
        }
        
        .cell-info-panel {
            background: rgba(10, 22, 40, 0.9);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid #4facfe;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .cell-info-panel h3 {
            font-size: 1.1rem;
            color: #4facfe;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(79, 172, 254, 0.3);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 0.85rem;
        }

        .info-item {
            display: flex;
            flex-direction: column;
        }

        .info-label {
            color: #a0c8ff;
            font-size: 0.75rem;
        }

        .info-value {
            font-weight: bold;
        }
        .phase-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(16, 32, 54, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #4facfe;
            font-size: 0.9rem;
            font-weight: bold;
            color: #4facfe;
            z-index: 1000;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        }
        
        @media (min-width: 768px) {
            .phase-indicator {
                top: 20px;
                right: 20px;
                padding: 15px 25px;
                font-size: 1.1rem;
            }
        }
        
        .view-mode-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            margin-bottom: 12px;
        }
        
        @media (min-width: 768px) {
            .view-mode-selector {
                gap: 8px;
                margin-bottom: 15px;
            }
        }
        
        .view-btn {
            padding: 10px 8px;
            margin: 0;
            font-size: 0.8rem;
        }
        
        @media (min-width: 768px) {
            .view-btn {
                padding: 8px;
                font-size: 0.85rem;
            }
        }
        
        .view-btn.active {
            background: linear-gradient(90deg, #00f2fe 0%, #4facfe 100%);
            color: #0a0e27;
        }
        
        footer {
            text-align: center;
            padding: 15px;
            color: #64748b;
            border-top: 1px solid rgba(79, 172, 254, 0.2);
            margin-top: 20px;
            font-size: 0.8rem;
        }
        
        @media (min-width: 768px) {
            footer {
                padding: 20px;
                margin-top: 30px;
                font-size: 0.85rem;
            }
        }
        
        .info-panel {
            background: rgba(16, 32, 54, 0.7);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(79, 172, 254, 0.2);
        }
        
        @media (min-width: 768px) {
            .info-panel {
                padding: 20px;
                margin-bottom: 20px;
            }
        }
        
        .info-text {
            color: #a0c8ff;
            line-height: 1.6;
            font-size: 0.85rem;
        }
        
        @media (min-width: 768px) {
            .info-text {
                font-size: 0.95rem;
            }
        }
        
        /* Improve touch targets on mobile */
        @media (hover: none) and (pointer: coarse) {
            button {
                min-height: 44px;
            }
            
            .slider::-webkit-slider-thumb {
                width: 28px;
                height: 28px;
            }
            
            .view-btn {
                min-height: 44px;
            }
        }
        
        /* Hide scrollbars but keep functionality */
        .canvas-wrapper::-webkit-scrollbar {
            display: none;
        }
        
        .canvas-wrapper {
            -ms-overflow-style: none;
        }
    </style>
</head>
<body>
    <div class="phase-indicator" id="phaseIndicator">
        Development: READY
    </div>
    
    <div class="container">
        <header>
            <h1>üß¨ LifeForge</h1>
            <div class="tagline">Watch life emerge from a single cell</div>
            <div class="subtitle">From DNA to organism through developmental biology</div>
        </header>
        
        <div class="info-panel">
            <div class="info-text">
                <strong>LifeForge simulates how a single cell becomes a complex organism.</strong> 
                Watch cells divide, differentiate into specialized types, and self-organize into patterns through chemical signals. 
                This is developmental biology in real-time - showing how genetic code becomes living form.
            </div>
        </div>
        
        <div class="main-layout">
            <div class="control-panel">
                <h2 class="panel-title">Development Controls</h2>
                
                <div class="control-group">
                    <button id="startBtn" class="primary">üß¨ Start Development</button>
                    <button id="pauseBtn" class="secondary">‚è∏ Pause</button>
                    <button id="resetViewBtn" class="secondary" title="Reset Pan & Zoom">üîç Reset View</button>
                    <button id="clearSelectionBtn" class="secondary" style="display: none;">‚ùå Clear Selection</button>
                    <button id="resetBtn" class="secondary">üîÑ Reset to Single Cell</button>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Development Speed</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="speedSlider" min="1" max="10" value="3" step="1" title="Development Speed">
                        <span class="slider-value" id="speedValue">3x</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Mutation Rate</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="mutationSlider" min="0" max="20" value="2" step="1" title="Mutation Rate">
                        <span class="slider-value" id="mutationValue">2%</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Morphogen Strength</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="morphogenSlider" min="1" max="10" value="5" step="1" title="Morphogen Strength">
                        <span class="slider-value" id="morphogenValue">5</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Cell Adhesion</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="adhesionSlider" min="0" max="100" value="10" step="1" title="Cell Adhesion Strength">
                        <span class="slider-value" id="adhesionValue">10%</span>
                    </div>
                </div>
                
                <h2 class="panel-title" style="margin-top: 30px;">Experiments</h2>
                
                <button id="symmetricBtn">ü¶ã Bilateral Symmetry</button>
                    <label class="control-label">Cell Division Rate</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="divisionSlider" min="1" max="10" value="5" step="1" title="Cell Division Rate">
                        <span class="slider-value" id="divisionValue">5</span>
                    </div>
                </div>
                
                <button id="segmentedBtn">üêõ Segmented Body</button>
                <button id="radialBtn">‚≠ê Radial Pattern</button>
                <button id="randomBtn">üé≤ Random Development</button>
                
                <h2 class="panel-title" style="margin-top: 30px;">Interventions</h2>

                <h2 class="panel-title" style="margin-top: 30px;">Environmental Factors</h2>

                <div class="control-group">
                    <label class="control-label">Temperature</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="temperatureSlider" min="0" max="100" value="50" step="1" title="Environment Temperature">
                        <span class="slider-value" id="temperatureValue">50¬∞C</span>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Toxicity</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="toxicitySlider" min="0" max="100" value="0" step="1" title="Environment Toxicity">
                        <span class="slider-value" id="toxicityValue">0%</span>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">Nutrient Level</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="nutrientSlider" min="10" max="200" value="100" step="1" title="Nutrient Availability">
                        <span class="slider-value" id="nutrientValue">100%</span>
                    </div>
                </div>
                
                <button id="mutateBtn" class="danger">‚ö° Cause Mutation</button>
                <button id="addCellsBtn">‚ûï Add Stem Cells</button>
                <button id="killCellsBtn" class="danger">üí• Kill Random Cells</button>
                
                <h2 class="panel-title" style="margin-top: 30px;">Export</h2>
                
                <button id="exportImageBtn">üì∏ Export as Image</button>
                <button id="exportDataBtn">üíæ Export Cell Data</button>
                <button id="exportStatsBtn">üìä Export Statistics</button>

                <h2 class="panel-title" style="margin-top: 30px;">Population Dynamics</h2>
                <div class="chart-container">
                    <canvas id="populationChart"></canvas>
                </div>
            </div>
            
            <div class="viz-container">
                <div class="view-mode-selector">
                    <button class="view-btn active" data-view="cells">Cell Types</button>
                    <button class="view-btn" data-view="chemicals">Chemicals</button>
                    <button class="view-btn" data-view="energy">Energy</button>
                    <button class="view-btn" data-view="genes">Gene Activity</button>
                </div>
                
                <div class="canvas-wrapper">
                    <canvas id="lifeCanvas"></canvas>
                </div>
                
                <div class="stats-bar">
                    <div class="stat-card">
                        <div class="stat-value" id="cellCount">1</div>
                        <div class="stat-label">Total Cells</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="stemCells">1</div>
                        <div class="stat-label">Stem Cells</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="divisions">0</div>
                        <div class="stat-label">Cell Divisions</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="generation">0</div>
                        <div class="stat-label">Generation</div>
                    </div>
                </div>
                
                <div class="cell-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #a855f7; color: #a855f7;"></div>
                        <span class="legend-label">Stem (Undifferentiated)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ef4444; color: #ef4444;"></div>
                        <span class="legend-label">Muscle (Movement)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3b82f6; color: #3b82f6;"></div>
                        <span class="legend-label">Neural (Sensing)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #10b981; color: #10b981;"></div>
                        <span class="legend-label">Digestive (Energy)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #f59e0b; color: #f59e0b;"></div>
                        <span class="legend-label">Structural (Support)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ec4899; color: #ec4899;"></div>
                        <span class="legend-label">Reproductive (Offspring)</span>
                    </div>

                <div class="cell-info-panel" id="cellInfoPanel" style="display: none;">
                    <h3>Selected Cell Info</h3>
                    <div class="info-grid">
                        <div class="info-item">
                            <span class="info-label">Type</span>
                            <span class="info-value" id="info-type"></span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Position (X, Y)</span>
                            <span class="info-value" id="info-pos"></span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Age</span>
                            <span class="info-value" id="info-age"></span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Generation</span>
                            <span class="info-value" id="info-gen"></span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Energy / Cooldown</span>
                            <span class="info-value"><span id="info-energy"></span> / <span id="info-cooldown"></span></span>
                        </div>
                    </div>
                </div>
                </div>
            </div>
        </div>
        
        <footer>
            LifeForge - Where information becomes form
            <br>Simulating the bridge between genotype and phenotype
        </footer>
    </div>

    <script>
        // ============================================
        // LIFEFORGE - DEVELOPMENTAL BIOLOGY SIMULATOR
        // ============================================
        
        const canvas = document.getElementById('lifeCanvas');
        const ctx = canvas.getContext('2d');
        
        // Configuration - define FIRST before anything else
        const Config = {
            cellSize: window.innerWidth < 640 ? 6 : 8,
            gridWidth: 0,
            gridHeight: 0,
            speed: 3,
            mutationRate: 0.02,
            morphogenStrength: 5,
            diffusionRate: 0.1, // How fast chemicals spread
            productionRate: 0.2, // How much chemical cells produce
            adhesionStrength: 0.1, // Chance for a cell to move to a better spot (0-1)
            divisionRate: 5,
            developmentMode: 'symmetric'
        };
        
        // Environmental factors
        const Environment = {
            temperature: 50, // Optimal is 50. Range: 0-100.
            toxicity: 0,     // Damage chance. Range: 0-100.
            nutrientLevel: 1.0 // Energy production multiplier. Range: 0.1-2.0.
        };
        
        // Set canvas size - define the function but DON'T call it yet
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            // Mobile-friendly height
            if (window.innerWidth < 768) {
                canvas.height = 400;
            } else {
                canvas.height = 600;
            }
            
            // Recalculate grid dimensions
            Config.gridWidth = Math.floor(canvas.width / Config.cellSize);
            Config.gridHeight = Math.floor(canvas.height / Config.cellSize);
            
            // Reinitialize morphogen field with new dimensions
            if (typeof morphogenField !== 'undefined') {
                morphogenField = new MorphogenField();
            }
            
            // Redraw if we have cells
            if (typeof cells !== 'undefined' && cells.length > 0) {
                draw();
            }
        }
        
        // Cell types with colors
        const CellTypes = {
            STEM: { name: 'stem', color: '#a855f7', glow: 'rgba(168, 85, 247, 0.5)' },
            MUSCLE: { name: 'muscle', color: '#ef4444', glow: 'rgba(239, 68, 68, 0.5)' },
            NEURAL: { name: 'neural', color: '#3b82f6', glow: 'rgba(59, 130, 246, 0.5)' },
            DIGESTIVE: { name: 'digestive', color: '#10b981', glow: 'rgba(16, 185, 129, 0.5)' },
            STRUCTURAL: { name: 'structural', color: '#f59e0b', glow: 'rgba(245, 158, 11, 0.5)' },
            REPRODUCTIVE: { name: 'reproductive', color: '#ec4899', glow: 'rgba(236, 72, 153, 0.5)' }
        };
        
        // Cell class
        class Cell {
            constructor(x, y, type = CellTypes.STEM, generation = 0) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.age = 0;
                this.generation = generation;
                // A new cell should start with its own internal energy store,
                // not inherit the parent's depleted energy.
                this.energy = 100; // Starting energy
                this.divisionCooldown = 0;
                this.isAlive = true;
                this.readyToDivide = false;
            }
            
            update(morphogenField) {
                this.age++;
                this.divisionCooldown = Math.max(0, this.divisionCooldown - 1);
                
                // --- Environmental Effects ---
                // 1. Temperature affects metabolism
                const tempDifference = Math.abs(Environment.temperature - 50); // 50 is optimal
                const metabolicCost = 0.1 + (tempDifference / 500); // Higher cost if not optimal
                this.energy -= metabolicCost;

                // 2. Toxicity can cause damage
                if (Math.random() < (Environment.toxicity / 100)) {
                    this.energy -= 5; // Direct energy damage from toxins
                }

                // Energy production (affected by nutrients)
                if (this.type === CellTypes.DIGESTIVE) {
                    const energyProduction = 0.5 * Environment.nutrientLevel;
                    this.energy = Math.min(200, this.energy + energyProduction);
                }

                // Apoptosis (programmed cell death) from starvation
                if (this.energy <= 0) {
                    this.isAlive = false;
                    return; // Stop updates for this dead cell
                }

                // Get chemical signals at position
                const signals = morphogenField.getSignalsAt(this.x, this.y);
                
                // Differentiation logic based on position and signals
                if (this.type === CellTypes.STEM && this.age > 10) {
                    this.differentiate(signals);
                }
                
                // Division readiness
                if (this.energy > 50 && this.divisionCooldown === 0 && this.age > 5 && Math.random() < Config.divisionRate / 100) {
                    // The cost of division should be paid *before* creating the new cell.
                    // This prevents the parent from having negative energy.
                    this.energy -= 40; // Cost to divide
                    this.readyToDivide = true;
                }
            }
            
            differentiate(signals) {
                // New differentiation logic based on dynamic chemical signals
                const { signalA, signalB, signalC } = signals;

                // Example logic:
                // High Signal A -> Neural
                // High Signal B -> Digestive
                // High Signal C -> Reproductive
                // Combinations -> Other types
                if (signalA > 0.5 && signalA > signalB && signalA > signalC) {
                    this.type = CellTypes.NEURAL;
                } else if (signalB > 0.5 && signalB > signalA && signalB > signalC) {
                    this.type = CellTypes.DIGESTIVE;
                } else if (signalC > 0.5) {
                    this.type = CellTypes.REPRODUCTIVE;
                } else if (signalA > 0.2 && signalB > 0.2) {
                    this.type = CellTypes.MUSCLE; // Interaction between A and B
                } else {
                    this.type = CellTypes.STRUCTURAL; // Default fallback
                }
                
                // Mutation chance
                if (Math.random() < Config.mutationRate) {
                    const types = [CellTypes.MUSCLE, CellTypes.NEURAL, CellTypes.DIGESTIVE, CellTypes.STRUCTURAL, CellTypes.REPRODUCTIVE];
                    this.type = types[Math.floor(Math.random() * types.length)];
                }
            }
        }
        
        // Morphogen field for chemical signaling
        class MorphogenField {
            constructor() {
                const size = Config.gridWidth * Config.gridHeight;
                // Three dynamic chemical signals
                this.signalA = new Float32Array(size);
                this.signalB = new Float32Array(size);
                this.signalC = new Float32Array(size);
                
                this.initialize();
            }
            
            initialize() {
                // Start with a clean slate
                this.signalA.fill(0);
                this.signalB.fill(0);
                this.signalC.fill(0);
            }
            
            update(cells) {
                // 1. Production/Consumption by cells
                cells.forEach(cell => {
                    const index = cell.y * Config.gridWidth + cell.x;
                    // Different cell types produce different signals
                    if (cell.type === CellTypes.NEURAL) {
                        this.signalA[index] = Math.min(1.0, this.signalA[index] + Config.productionRate);
                    } else if (cell.type === CellTypes.DIGESTIVE) {
                        this.signalB[index] = Math.min(1.0, this.signalB[index] + Config.productionRate);
                    } else if (cell.type === CellTypes.REPRODUCTIVE) {
                        this.signalC[index] = Math.min(1.0, this.signalC[index] + Config.productionRate);
                    }
                });

                // 2. Diffusion and Decay
                this.diffuse(this.signalA);
                this.diffuse(this.signalB);
                this.diffuse(this.signalC);
            }

            diffuse(grid) {
                const nextGrid = new Float32Array(grid.length);
                const decay = 0.99; // Natural decay rate

                for (let y = 0; y < Config.gridHeight; y++) {
                    for (let x = 0; x < Config.gridWidth; x++) {
                        const index = y * Config.gridWidth + x;
                        let sum = 0;
                        let count = 0;

                        // Get neighbor values
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < Config.gridWidth && ny >= 0 && ny < Config.gridHeight) {
                                    sum += grid[ny * Config.gridWidth + nx];
                                    count++;
                                }
                            }
                        }

                        const average = sum / count;
                        const currentVal = grid[index];
                        // Move towards the average of neighbors (diffusion) and apply decay
                        nextGrid[index] = (currentVal + (average - currentVal) * Config.diffusionRate) * decay;
                    }
                }
                // Copy the new values back to the original grid
                grid.set(nextGrid);
            }
            
            getSignalsAt(x, y) {
                const index = y * Config.gridWidth + x;
                return {
                    signalA: this.signalA[index] || 0,
                    signalB: this.signalB[index] || 0,
                    signalC: this.signalC[index] || 0
                };
            }
        }
        
        // Main simulation state
        let cells = [];
        let morphogenField = new MorphogenField();
        let running = false;
        let time = 0;
        let totalDivisions = 0;
        let currentPhase = '';
        let viewMode = 'cells';
        let selectedCell = null;
        let transform = {
            // Start slightly zoomed out on mobile for a better overview
            scale: window.innerWidth < 768 ? 0.5 : 1, // Consolidated scale initialization
            offsetX: 0,
            offsetY: 0
        };
        let isPanning = false;
        let lastMousePos = { x: 0, y: 0 };
        
        let populationHistory = [];
        let populationChart = null;
        
        // Initialize with single cell
        function initialize() {
            cells = [new Cell(
                Math.floor(Config.gridWidth / 2),
                Math.floor(Config.gridHeight / 2),
                CellTypes.STEM,
                0
            )];
            totalDivisions = 0;
            time = 0;
            updateStats();
            updatePhase();
            initializeChart();
            clearSelection();
            // Reset view on simulation reset
            transform = {
                scale: 1,
                offsetX: 0,
                offsetY: 0
            };
        }
        
        // Update simulation
        function update() {
            if (!running) return;
            
            time++;

            // Record history for the chart every 10 cycles
            if (time % 10 === 0) {
                recordPopulationHistory();
                updateChart();
            }
            
            // Update the chemical field based on current cell locations
            morphogenField.update(cells);

            // Filter out dead cells first
            cells = cells.filter(cell => cell.isAlive);

            // Update all cells
            cells.forEach(cell => cell.update(morphogenField));
            
            // --- Improved Energy Distribution ---
            // Use a map for efficient neighbor lookup (O(1) average)
            const cellMap = new Map(cells.map(c => [`${c.x},${c.y}`, c]));
            
            // Apply adhesion forces to make cells stick together
            applyAdhesion(cellMap);

            // Update nervous system: firing, propagation, and actuation
            updateNervousSystem(cellMap);

            const energyTransfers = [];

            cells.forEach(cell => {
                if (cell.type === CellTypes.DIGESTIVE) {
                    cell.energy = Math.min(100, cell.energy + 0.5); // Digestive cells produce energy
                }
                // Calculate energy to share with neighbors
                getNeighborCoordinates(cell).forEach(({nx, ny}) => {
                    const neighbor = cellMap.get(`${nx},${ny}`);
                    if (neighbor.energy < cell.energy) {
                    if (neighbor && neighbor.energy < cell.energy) { // Check if neighbor exists
                        const transfer = (cell.energy - neighbor.energy) * 0.01;
                        energyTransfers.push({ from: cell, to: neighbor, amount: transfer });
                    }
                });
            });

            // Apply all transfers at once to avoid race conditions
            energyTransfers.forEach(({ from, to, amount }) => {
                from.energy -= amount;
                to.energy += amount;
            });

            const newCells = [];
            cells.forEach(cell => {
                if (cell.readyToDivide && cells.length < 2000) {
                    // Find empty neighbor
                    const directions = [
                        {dx: 1, dy: 0}, {dx: -1, dy: 0},
                        {dx: 0, dy: 1}, {dx: 0, dy: -1}
                    ];
                    
                    for (const dir of directions) {
                        const nx = cell.x + dir.dx;
                        const ny = cell.y + dir.dy;
                        
                        if (nx >= 0 && nx < Config.gridWidth && ny >= 0 && ny < Config.gridHeight) {
                            const occupied = cells.some(c => c.x === nx && c.y === ny);
                            if (!occupied) {
                                const newCell = new Cell(nx, ny, CellTypes.STEM, cell.generation + 1);
                                // The new cell should start with its own energy, not inherit from the parent.
                                // The parent already paid the energy cost.
                                newCells.push(newCell);
                                cell.divisionCooldown = 30;
                                cell.readyToDivide = false;
                                totalDivisions++;
                                break;
                            }
                        }
                    }
                }
            });
            
            cells.push(...newCells);
            
            // Update display
            draw();
            updateStats();
            updatePhase();
            
            requestAnimationFrame(update);
        }

        function getNeighborCoordinates(cell) {
            const coords = [];
            const directions = [{dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1}];
            for (const dir of directions) {
                coords.push({ nx: cell.x + dir.dx, ny: cell.y + dir.dy });
            }
            return coords;
        }
        
        function applyAdhesion(cellMap) {
            if (Config.adhesionStrength === 0) return;

            const moves = [];

            for (const cell of cells) {
                if (Math.random() > Config.adhesionStrength) continue;

                const currentNeighbors = getNeighborCoordinates(cell)
                    .filter(coord => cellMap.has(`${coord.nx},${coord.ny}`))
                    .length;

                let bestSpot = null;
                let maxNeighbors = currentNeighbors;

                // Find empty neighbor spots
                const emptyNeighbors = getNeighborCoordinates(cell)
                    .filter(coord => !cellMap.has(`${coord.nx},${coord.ny}`) &&
                        coord.nx >= 0 && coord.nx < Config.gridWidth &&
                        coord.ny >= 0 && coord.ny < Config.gridHeight);

                for (const spot of emptyNeighbors) {
                    // How many neighbors would the cell have in this new spot?
                    const potentialNeighbors = getNeighborCoordinates({ x: spot.nx, y: spot.ny })
                        .filter(coord => {
                            // A neighbor is another cell, not including itself in its old position
                            const isOccupied = cellMap.has(`${coord.nx},${coord.ny}`);
                            const isSelf = coord.nx === cell.x && coord.ny === cell.y;
                            return isOccupied && !isSelf;
                        }).length + 1; // +1 for the original cell it's moving away from if still adjacent

                    if (potentialNeighbors > maxNeighbors) {
                        maxNeighbors = potentialNeighbors;
                        bestSpot = spot;
                    }
                }

                if (bestSpot) {
                    moves.push({ cell, to: { x: bestSpot.nx, y: bestSpot.ny } });
                }
            }

            // Apply valid moves (preventing collisions)
            const occupiedTargets = new Set();
            for (const move of moves) {
                const targetKey = `${move.to.x},${move.to.y}`;
                if (!occupiedTargets.has(targetKey) && !cellMap.has(targetKey)) {
                    // Update cell's position
                    move.cell.x = move.to.x;
                    move.cell.y = move.to.y;
                    occupiedTargets.add(targetKey);
                }
            }
        }
        
        function updateNervousSystem(cellMap) {
            const firingNeurons = new Set();

            // --- Calculate Environmental Stimulus ---
            let baseStimulus = 0.05; // Base pacemaker activity
            
            // Toxicity adds significant stimulus
            baseStimulus += (Environment.toxicity / 100) * 0.2; 

            // Temperature deviation from optimal (50) adds stimulus
            const tempDifference = Math.abs(Environment.temperature - 50);
            baseStimulus += (tempDifference / 50) * 0.1;

            // Nutrient levels modulate the final stimulus
            const finalStimulus = baseStimulus * Environment.nutrientLevel;

            // --- Pass 1: Voltage Buildup & Firing Check ---
            cells.forEach(cell => {
                // Decrement all cooldowns
                cell.fireCooldown = Math.max(0, cell.fireCooldown - 1);
                cell.contractCooldown = Math.max(0, cell.contractCooldown - 1);
                if (cell.contractCooldown === 0) cell.isContracting = false;

                if (cell.type === CellTypes.NEURAL && cell.fireCooldown === 0) {
                    // Neural cells slowly build voltage (pacemaker behavior)
                    cell.voltage += 0.1;

                    // Apply the calculated environmental stimulus
                    cell.voltage += finalStimulus;
                    // Fire if voltage threshold is met
                    if (cell.voltage >= 1.0) {
                        cell.isFiring = true;
                        cell.voltage = 0;
                        cell.fireCooldown = 20; // Refractory period
                        cell.energy -= 2; // Firing costs energy
                        firingNeurons.add(cell);
                    } else {
                        cell.isFiring = false;
                    }
                }
            });

            // --- Pass 2: Signal Propagation & Actuation ---
            firingNeurons.forEach(firingNeuron => {
                getNeighborCoordinates(firingNeuron).forEach(({ nx, ny }) => {
                    const neighbor = cellMap.get(`${nx},${ny}`);
                    if (!neighbor) return;

                    // Propagate signal to other neural cells
                    if (neighbor.type === CellTypes.NEURAL && neighbor.fireCooldown === 0) {
                        neighbor.voltage += 0.6; // Excite neighbor
                    }

                    // Trigger muscle cells
                    if (neighbor.type === CellTypes.MUSCLE && neighbor.contractCooldown === 0) {
                        neighbor.isContracting = true;
                        neighbor.contractCooldown = 15; // Contraction duration
                        neighbor.energy -= 5; // Contraction costs energy
                    }
                });
            });
        }
        
        // Draw cells
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a0e1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply pan and zoom transformation
            ctx.save();
            ctx.translate(transform.offsetX, transform.offsetY);
            ctx.scale(transform.scale, transform.scale);

            if (viewMode === 'cells') {
                drawCells();
            } else if (viewMode === 'chemicals') {
                drawChemicals();
            } else if (viewMode === 'energy') {
                drawEnergy();
            } else if (viewMode === 'genes') {
                drawGeneActivity();
            }

            // Restore context to default state
            ctx.restore();
        }
        
        function drawCells() {
            cells.forEach(cell => {
                const x = cell.x * Config.cellSize;
                const y = cell.y * Config.cellSize;
                
                // Cell body
                ctx.fillStyle = cell.type.color;
                ctx.beginPath();
                ctx.arc(x + Config.cellSize/2, y + Config.cellSize/2, Config.cellSize/2 - 1, 0, Math.PI * 2);
                ctx.fill();

                // Add visual feedback for firing/contracting
                if (cell.isFiring || cell.isContracting) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(x + Config.cellSize / 2, y + Config.cellSize / 2, Config.cellSize / 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Glow effect
                if (cell.age < 10) {
                    ctx.shadowColor = cell.type.glow;
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });

            // Highlight selected cell
            if (selectedCell && selectedCell.isAlive) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2 / transform.scale; // Keep line width consistent
                ctx.beginPath();
                const radius = Config.cellSize / 2;
                ctx.arc(selectedCell.x * Config.cellSize + radius, selectedCell.y * Config.cellSize + radius, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        function drawChemicals() {
            // Draw morphogen gradient
            for (let y = 0; y < Config.gridHeight; y++) {
                for (let x = 0; x < Config.gridWidth; x++) {
                    const signals = morphogenField.getSignalsAt(x, y);
                    const intensity = signals.ap * 255;
                    
                    ctx.fillStyle = `rgba(79, 172, 254, ${intensity / 255 * 0.5})`;
                    ctx.fillRect(x * Config.cellSize, y * Config.cellSize, Config.cellSize, Config.cellSize);
                }
            }
            
            // Draw cells on top
            cells.forEach(cell => {
                const x = cell.x * Config.cellSize;
                const y = cell.y * Config.cellSize;
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(x + Config.cellSize/2, y + Config.cellSize/2, Config.cellSize/3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawEnergy() {
            cells.forEach(cell => {
                const x = cell.x * Config.cellSize;
                const y = cell.y * Config.cellSize;

                // Normalize energy to a 0-1 range for coloring
                // Cap at 150 for a good visual range
                const normalizedEnergy = Math.min(cell.energy / 150, 1.0);

                // Create a color gradient from blue (low energy) to yellow (high energy)
                const hue = 240 - (normalizedEnergy * 180); // 240 (blue) -> 60 (yellow)
                const lightness = 30 + (normalizedEnergy * 40); // 30% -> 70%

                ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
                ctx.beginPath();
                ctx.arc(x + Config.cellSize / 2, y + Config.cellSize / 2, Config.cellSize / 2 - 1, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawGeneActivity() {
            cells.forEach(cell => {
                const x = cell.x * Config.cellSize;
                const y = cell.y * Config.cellSize;
                
                // Color by gene expression (age-based as proxy)
                const activity = Math.min(cell.age / 50, 1);
                const r = Math.floor(activity * 255);
                const g = Math.floor((1 - activity) * 255);
                
                ctx.fillStyle = `rgb(${r}, ${g}, 100)`;
                ctx.fillRect(x, y, Config.cellSize, Config.cellSize);
                
                // Highlight dividing cells
                if (cell.readyToDivide) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, Config.cellSize, Config.cellSize);
                }
            });
        }
        
        // Update statistics
        function updateStats() {
            const stats = getStatistics();
            document.getElementById('cellCount').textContent = stats.totalCells.toLocaleString();
            document.getElementById('stemCells').textContent = stats.stemCells.toLocaleString();
            document.getElementById('divisions').textContent = stats.totalDivisions.toLocaleString();
            document.getElementById('generation').textContent = stats.maxGeneration.toLocaleString();
        }

        function getStatistics() {
            const stats = {
                totalCells: cells.length,
                totalDivisions: totalDivisions,
                maxGeneration: cells.length > 0 ? Math.max(...cells.map(c => c.generation)) : 0
            };

            // Initialize cell type counts dynamically
            Object.values(CellTypes).forEach(type => {
                stats[`${type.name}Cells`] = 0;
            });

            // Tally cells
            cells.forEach(cell => {
                const typeName = cell.type.name;
                const key = `${typeName}Cells`;
                stats[key]++;
            });

            return stats;
        }

        // Update phase indicator
        function updatePhase() {
            if (cells.length === 1) {
                phase = 'SINGLE CELL';
            } else if (cells.length < 10) {
                phase = 'EARLY DIVISION';
            } else if (cells.length < 50) {
                phase = 'DIFFERENTIATION';
            } else if (cells.length < 200) {
                phase = 'MORPHOGENESIS';
            } else {
                phase = 'MATURE ORGANISM';
            }
            
            currentPhase = phase;
            document.getElementById('phaseIndicator').textContent = `Development: ${currentPhase}`;
        }
        
        // Charting functions
        function initializeChart() {
            const chartCanvas = document.getElementById('populationChart');
            if (populationChart) {
                populationChart.destroy();
            }

            populationHistory = [];

            const datasets = Object.values(CellTypes).map(type => ({
                label: type.name.charAt(0).toUpperCase() + type.name.slice(1),
                data: [],
                borderColor: type.color,
                backgroundColor: type.glow,
                fill: false,
                borderWidth: 2,
                pointRadius: 0,
                tension: 0.4
            }));

            populationChart = new Chart(chartCanvas, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 200
                    },
                    scales: {
                        x: {
                            ticks: { color: '#a0c8ff' },
                            grid: { color: 'rgba(79, 172, 254, 0.1)' }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#a0c8ff' },
                            grid: { color: 'rgba(79, 172, 254, 0.2)' }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#e0f0ff',
                                boxWidth: 12,
                                font: { size: 10 }
                            }
                        }
                    }
                }
            });
        }

        function recordPopulationHistory() {
            const stats = getStatistics();
            const historyPoint = { time: time };
            Object.values(CellTypes).forEach(type => {
                historyPoint[type.name] = stats[`${type.name}Cells`] || 0;
            });
            populationHistory.push(historyPoint);
            if (populationHistory.length > 100) { // Keep history to a reasonable size
                populationHistory.shift();
            }
        }

        function updateChart() {
            populationChart.data.labels = populationHistory.map(p => p.time);
            populationChart.data.datasets.forEach(dataset => {
                const typeName = dataset.label.toLowerCase();
                dataset.data = populationHistory.map(p => p[typeName]);
            });
            populationChart.update();
        }

        // Control event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!running) {
                running = true;
                update();
            }
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            running = false;
        });
        
        document.getElementById('resetViewBtn').addEventListener('click', () => {
            transform = { scale: 1, offsetX: 0, offsetY: 0 };
            draw();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            running = false;
            clearSelection();
            initialize();
            draw();
        });
        
        document.getElementById('speedSlider').addEventListener('input', function() {
            Config.speed = parseInt(this.value);
            document.getElementById('speedValue').textContent = this.value + 'x';
        });
        
        document.getElementById('mutationSlider').addEventListener('input', function() {
            Config.mutationRate = parseInt(this.value) / 100;
            document.getElementById('mutationValue').textContent = this.value + '%';
        });
        
        document.getElementById('morphogenSlider').addEventListener('input', function() {
            Config.morphogenStrength = parseInt(this.value);
            document.getElementById('morphogenValue').textContent = this.value;
        });
        
        document.getElementById('divisionSlider').addEventListener('input', function() {
            Config.divisionRate = parseInt(this.value);
            document.getElementById('divisionValue').textContent = this.value;
        });
        
        document.getElementById('adhesionSlider').addEventListener('input', function() {
            Config.adhesionStrength = parseInt(this.value) / 100;
            document.getElementById('adhesionValue').textContent = this.value + '%';
        });

        // Environment sliders
        document.getElementById('temperatureSlider').addEventListener('input', function() {
            Environment.temperature = parseInt(this.value);
            document.getElementById('temperatureValue').textContent = `${this.value}¬∞C`;
        });

        document.getElementById('toxicitySlider').addEventListener('input', function() {
            Environment.toxicity = parseInt(this.value);
            document.getElementById('toxicityValue').textContent = `${this.value}%`;
        });

        document.getElementById('nutrientSlider').addEventListener('input', function() {
            Environment.nutrientLevel = parseInt(this.value) / 100;
            document.getElementById('nutrientValue').textContent = `${this.value}%`;
        });
        
        // Experiment buttons
        document.getElementById('symmetricBtn').addEventListener('click', () => {
            Config.developmentMode = 'symmetric';
            initialize();
            draw();
        });
        
        document.getElementById('segmentedBtn').addEventListener('click', () => {
            Config.developmentMode = 'segmented';
            initialize();
            draw();
        });
        
        document.getElementById('radialBtn').addEventListener('click', () => {
            Config.developmentMode = 'radial';
            initialize();
            draw();
        });
        
        document.getElementById('randomBtn').addEventListener('click', () => {
            Config.developmentMode = 'random';
            initialize();
            draw();
        });
        
        // Intervention buttons
        document.getElementById('mutateBtn').addEventListener('click', () => {
            cells.forEach(cell => {
                if (Math.random() < 0.3) {
                    const types = [CellTypes.MUSCLE, CellTypes.NEURAL, CellTypes.DIGESTIVE, CellTypes.STRUCTURAL, CellTypes.REPRODUCTIVE];
                    cell.type = types[Math.floor(Math.random() * types.length)];
                }
            });
            draw();
        });
        
        document.getElementById('addCellsBtn').addEventListener('click', () => {
            for (let i = 0; i < 10; i++) {
                const x = Math.floor(Math.random() * Config.gridWidth);
                const y = Math.floor(Math.random() * Config.gridHeight);
                const occupied = cells.some(c => c.x === x && c.y === y);
                if (!occupied) {
                    cells.push(new Cell(x, y, CellTypes.STEM, 0));
                }
            }
            updateStats();
            draw();
        });
        
        document.getElementById('killCellsBtn').addEventListener('click', () => {
            const toRemove = Math.floor(cells.length * 0.2);
            for (let i = 0; i < toRemove; i++) {
                const index = Math.floor(Math.random() * cells.length);
                cells.splice(index, 1);
            }
            updateStats();
            draw();
        });
        
        // View mode buttons
        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                viewMode = this.dataset.view;
                draw();
            });
        });
        
        // Export functions
        document.getElementById('exportImageBtn').addEventListener('click', () => {
            // Create a temporary canvas with white background
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');
            
            // Fill with dark background
            exportCtx.fillStyle = '#0a0e1a';
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Draw current canvas content
            exportCtx.drawImage(canvas, 0, 0);
            
            // Add title and info
            exportCtx.fillStyle = '#4facfe';
            exportCtx.font = 'bold 20px Arial';
            exportCtx.fillText('LifeForge - Developmental Biology', 10, 30);
            
            exportCtx.fillStyle = '#a0c8ff';
            exportCtx.font = '14px Arial';
            exportCtx.fillText(`Cells: ${cells.length} | Phase: ${currentPhase}`, 10, 55);
            exportCtx.fillText(`Mode: ${Config.developmentMode} | Time: ${time}`, 10, 75);
            
            // Convert to download
            exportCanvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lifeforge-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        });
        
        document.getElementById('exportDataBtn').addEventListener('click', () => {
            // Create comprehensive cell data export
            const currentStats = getStatistics();

            const exportData = {
                metadata: {
                    timestamp: new Date().toISOString(),
                    developmentTime: time, // This is good, let's ensure it's always a number.
                    phase: document.getElementById('phaseIndicator').textContent,
                    developmentMode: Config.developmentMode,
                    config: { ...Config }
                },
                statistics: {
                    ...currentStats,
                },
                cells: cells.map(cell => ({
                    x: cell.x,
                    y: cell.y,
                    type: cell.type.name,
                    age: cell.age,
                    generation: cell.generation,
                    energy: cell.energy
                }))
            };
            
            // Convert to JSON and download
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lifeforge-data-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });
        
        document.getElementById('exportStatsBtn').addEventListener('click', () => {
            // Create human-readable statistics report
            const stats = getStatistics();
            
            const totalCellsForPercent = stats.totalCells > 0 ? stats.totalCells : 1;
            const cellDistribution = Object.keys(CellTypes).map(key => {
                const type = CellTypes[key];
                const count = stats[`${type.name}Cells`] || 0;
                const percentage = (count / totalCellsForPercent * 100).toFixed(1);
                return `${type.color.slice(0,1) === '#' ? 'üü£' : 'üî¥'} ${type.name.charAt(0).toUpperCase() + type.name.slice(1)} Cells: ${' '.repeat(15 - type.name.length)}${count} (${percentage}%)`;
            }).join('\n');

            const report = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              LIFEFORGE DEVELOPMENT REPORT                      ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Generated: ${new Date().toLocaleString()}
Development Mode: ${Config.developmentMode}
Development Phase: ${currentPhase}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ORGANISM STATISTICS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Total Cells:              ${stats.totalCells}
Cell Divisions:           ${stats.totalDivisions}
Maximum Generation:       ${stats.maxGeneration}
Development Time:         ${time}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
CELL TYPE DISTRIBUTION
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

${cellDistribution}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
DEVELOPMENT PARAMETERS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Cell Size:                ${Config.cellSize}px
Grid Dimensions:          ${Config.gridWidth}x${Config.gridHeight}
Mutation Rate:            ${(Config.mutationRate * 100).toFixed(1)}%
Morphogen Strength:       ${Config.morphogenStrength}
Division Rate:            ${Config.divisionRate}
Simulation Speed:         ${Config.speed}x

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ANALYSIS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Differentiation Progress: ${((1 - (stats.stemCells || 0)/totalCellsForPercent) * 100).toFixed(1)}%

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Generated by LifeForge - Developmental Biology Simulator
Where information becomes form
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
`;
            
            // Download as text file
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `lifeforge-report-${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // Initialize on load - CALL EVERYTHING AT THE END
        window.addEventListener('load', () => {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            initialize();
            draw();

            // --- Pan and Zoom Event Listeners ---
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // World coordinates before zoom
                const worldX = (mouseX - transform.offsetX) / transform.scale;
                const worldY = (mouseY - transform.offsetY) / transform.scale;

                const zoomFactor = 1.1;
                const oldScale = transform.scale;

                if (e.deltaY < 0) {
                    transform.scale *= zoomFactor;
                } else {
                    transform.scale /= zoomFactor;
                }
                // Clamp scale
                transform.scale = Math.max(0.1, Math.min(transform.scale, 20));

                // Adjust offset to keep mouse position fixed in world space
                transform.offsetX = mouseX - worldX * transform.scale;
                transform.offsetY = mouseY - worldY * transform.scale;

                draw();
            });

            const startPan = (e) => {
                isPanning = true;
                lastMousePos.x = e.clientX || e.touches[0].clientX;
                lastMousePos.y = e.clientY || e.touches[0].clientY;
                canvas.style.cursor = 'grabbing';
            };

            const doPan = (e) => {
                if (!isPanning) return;
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;

                const dx = clientX - lastMousePos.x;
                const dy = clientY - lastMousePos.y;

                transform.offsetX += dx;
                transform.offsetY += dy;

                lastMousePos.x = clientX;
                lastMousePos.y = clientY;

                draw();
            };

            const endPan = () => {
                isPanning = false;
                canvas.style.cursor = 'grab';
            };

            canvas.addEventListener('mousedown', startPan);
            canvas.addEventListener('mousemove', doPan);
            canvas.addEventListener('mouseup', endPan);
            canvas.addEventListener('mouseleave', endPan);

            canvas.addEventListener('touchstart', startPan, { passive: true });
            canvas.addEventListener('touchmove', doPan, { passive: true });
            canvas.addEventListener('touchend', endPan);

            // --- Cell Selection Listener ---
            document.getElementById('clearSelectionBtn').addEventListener('click', () => {
                clearSelection();
            });

            canvas.addEventListener('click', handleCanvasClick);
        });

        function clearSelection() {
            selectedCell = null;
            updateCellInfoPanel();
            draw();
        }

        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Convert mouse coordinates to world coordinates
            const worldX = (mouseX - transform.offsetX) / transform.scale;
            const worldY = (mouseY - transform.offsetY) / transform.scale;

            // Convert world coordinates to grid coordinates
            const gridX = Math.floor(worldX / Config.cellSize);
            const gridY = Math.floor(worldY / Config.cellSize);

            // Find the cell at the clicked grid position
            const clickedCell = cells.find(c => c.x === gridX && c.y === gridY);

            if (clickedCell) {
                selectedCell = clickedCell;
                updateCellInfoPanel();
                draw(); // Redraw to show selection highlight
            }
        }

        function updateCellInfoPanel() {
            const panel = document.getElementById('cellInfoPanel');
            const clearBtn = document.getElementById('clearSelectionBtn');
            if (selectedCell && selectedCell.isAlive) {
                panel.style.display = 'block';
                clearBtn.style.display = 'block';
                document.getElementById('info-type').textContent = selectedCell.type.name.charAt(0).toUpperCase() + selectedCell.type.name.slice(1);
                document.getElementById('info-pos').textContent = `${selectedCell.x}, ${selectedCell.y}`;
                document.getElementById('info-age').textContent = selectedCell.age;
                document.getElementById('info-gen').textContent = selectedCell.generation;
                document.getElementById('info-energy').textContent = selectedCell.energy.toFixed(1);
                document.getElementById('info-cooldown').textContent = selectedCell.divisionCooldown;
            } else {
                panel.style.display = 'none';
                clearBtn.style.display = 'none';
            }
        }
    </script>
</body>
</html>